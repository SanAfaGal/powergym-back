import logging
from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, status
from sqlalchemy.orm import Session

from app.api.dependencies import get_current_active_user
from app.core.config import settings
from app.db.session import get_db
from app.schemas.reward import (
    Reward,
    RewardApplyInput,
    RewardConfig,
    RewardEligibilityResponse,
)
from app.schemas.user import User
from app.services.reward_service import RewardService

logger = logging.getLogger(__name__)

router = APIRouter(tags=["rewards"])


@router.post(
    "/subscriptions/{subscription_id}/rewards/calculate",
    response_model=RewardEligibilityResponse,
    status_code=status.HTTP_200_OK,
    summary="Calculate reward eligibility",
    description="Calculate eligibility for a reward based on subscription cycle attendances"
)
def calculate_reward_eligibility(
        subscription_id: UUID,
        current_user: User = Depends(get_current_active_user),
        db: Session = Depends(get_db)
) -> RewardEligibilityResponse:
    """
    Calculate eligibility for a reward.

    This endpoint:
    - Verifies subscription exists (can be active or terminated)
    - Checks if plan is monthly
    - Counts attendances in the cycle (from start_date to today if active, or to end_date if terminated)
    - Creates reward if eligible (>= 20 attendances)
    """
    return RewardService.calculate_eligibility(db, subscription_id)


@router.get(
    "/clients/{client_id}/rewards/available",
    response_model=List[Reward],
    status_code=status.HTTP_200_OK,
    summary="Get available rewards for client",
    description="Get all available (pending and not expired) rewards for a client"
)
def get_available_rewards(
        client_id: UUID,
        current_user: User = Depends(get_current_active_user),
        db: Session = Depends(get_db)
) -> List[Reward]:
    """
    Get available rewards for a client.

    Returns rewards with:
    - status = 'pending'
    - expires_at > NOW()
    """
    return RewardService.get_available_rewards(db, client_id)


@router.get(
    "/subscriptions/{subscription_id}/rewards",
    response_model=List[Reward],
    status_code=status.HTTP_200_OK,
    summary="Get rewards for subscription",
    description="Get all rewards generated by a specific subscription"
)
def get_rewards_by_subscription(
        subscription_id: UUID,
        current_user: User = Depends(get_current_active_user),
        db: Session = Depends(get_db)
) -> List[Reward]:
    """
    Get all rewards for a subscription.
    """
    return RewardService.get_rewards_by_subscription(db, subscription_id)


@router.post(
    "/rewards/{reward_id}/apply",
    response_model=Reward,
    status_code=status.HTTP_200_OK,
    summary="Apply reward",
    description="Manually apply a reward discount to a subscription"
)
def apply_reward(
        reward_id: UUID,
        apply_data: RewardApplyInput,
        current_user: User = Depends(get_current_active_user),
        db: Session = Depends(get_db)
) -> Reward:
    """
    Apply a reward to a subscription.

    This endpoint:
    - Validates reward exists and is pending
    - Validates reward is not expired
    - Validates subscription exists
    - Updates reward status to 'applied'
    - Marks applied_at and applied_subscription_id
    """
    return RewardService.apply_reward(db, reward_id, apply_data)


@router.get(
    "/rewards/config",
    response_model=RewardConfig,
    status_code=status.HTTP_200_OK,
    summary="Get reward configuration",
    description="Get the current reward system configuration (attendance threshold, discount percentage, expiration days, eligible plan units). This endpoint is public and does not require authentication."
)
def get_reward_config() -> RewardConfig:
    """
    Get the current reward system configuration.

    Returns the configuration values that determine:
    - Minimum attendances required to qualify for a reward
    - Default discount percentage
    - Number of days until reward expires
    - Which plan duration units are eligible for rewards

    This endpoint is public and can be accessed without authentication
    to allow the frontend to display accurate reward rules.

    Returns:
        RewardConfig: Current reward configuration settings

    Raises:
        HTTPException: If there's an error retrieving configuration
    """
    try:
        return RewardConfig(
            attendance_threshold=settings.REWARD_ATTENDANCE_THRESHOLD,
            discount_percentage=settings.REWARD_DISCOUNT_PERCENTAGE,
            expiration_days=settings.REWARD_EXPIRATION_DAYS,
            eligible_plan_units=settings.REWARD_ELIGIBLE_PLAN_UNITS
        )
    except Exception as e:
        # Log error but return a generic message to avoid exposing internal details
        logger.error(f"Error retrieving reward configuration: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error retrieving reward configuration"
        )

